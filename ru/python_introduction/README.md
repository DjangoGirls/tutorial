# Введение в Python

> Часть этой главы основана на учебных пособиях Geek Girls Carrots (https://github.com/ggcarrots/django-carrots).

Давай напишем немного кода!

## Консоль Python

Чтобы начать играть с Python, нам нужно открыть *командную строку* на твоем компьютере. Ты уже должна знать, как это сделать -- мы изучали это в главе [Введение в интерфейс командой строки][1].

 [1]: ../intro_to_command_line/README.md

После того, как будешь готова, следуйте приведенным ниже инструкциям.

Мы хотим открыть консоль Python, так что набери `python` если работаешь в Windows, или `python3` для Mac OS/Linux, и нажми `enter`.

    $ python3
    Python 3.4.3 (...)
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
    

## Твоя первая команда Python!

После запуска Python, консоль изменилась на `>>>`. Для нас это означает, что сейчас мы можем использовать только команды на языке Python. Тебе не нужно вводить `>>>` - Python будет делать это за нас.

Если ты хочешь выйти из консоли Python, в любой момент -- просто введи `exit()` или используй сочетание клавиш `Ctrl + Z` для Windows и `Ctrl + D` для Mac/Linux. Тогда ты больше не будешь видеть `>>>`.

Пока что мы не хотим выходить из консоли Python. Мы хотим узнать больше о ней. Давай начнём с чего-нибудь совсем простого. Например, попробуй набрать простое математическое выражение, вроде `2 + 3` и нажми `enter`.

    >>> 2 + 3
    5
    

Прекрасно! Видишь, как выскочил ответ? Python знает математику! Ты можешь попробовать другие команды, такие как: - `4 * 5` - `5 - 1` - `40 / 2`

Поиграй с этим немного и затем вернись сюда :).

Как видишь, Python является прекрасным калькулятором. Если тебе интересно, что еще можно сделать...

## Строки

Как насчет твоего имени? Введи свое имя в кавычках, вот так:

    >>> "Ola"
    'Ola'
    

Сейчас ты создала свою первую строку! Это последовательность символов, которые могут быть обработаны компьютером. Строка должна всегда начинаться и заканчиваться одинаковым символом. Им может быть одинарная (`'`) или двойная (`"`) кавычка (разницы нет!) Кавычки говорят Python'у, что внутри них находится строка.

Строки могут быть слиты воедино. Попробуй так:

    >>> "Hi there " + "Ola"
    'Hi there Ola'
    

Ты также можешь умножать строки на число:

    >>> "Ola" * 3
    'OlaOlaOla'
    

Если тебе нужно поставить апостроф внутри строки, то есть два способа сделать это.

Использование двойных кавычек:

    >>> "Runnin' down the hill"
    "Runnin' down the hill"
    

или предварение апострофа обратной косой чертой (``):

    >>> 'Runnin\' down the hill'
    "Runnin' down the hill"
    

Прикольно, да? Чтобы увидеть своё имя прописными буквами, просто набери:

    >>> "Ola".upper()
    'OLA'
    

Ты только что использовала **функцию** `upper` для своей строки! Функция (такая как `upper()`) представляет собой набор инструкций, который должен выполнить Python на заданном объекте (в нашем случае: `"Ola"`) при её вызове.

Если ты хочешь узнать количество букв в своём имени, то и для этого тоже существует функция!

    >>> len("Ola")
    3
    

Интересно, почему иногда мы вызываем функцию добавлением `.` к концу строки (как `"Ola".upper()`), а иногда сначала пишем имя функции и затем помещаем строку в скобки? Ну, в некоторых случаях функции принадлежат объектам, например функция `upper()`, которая может быть применена только к строкам. В этом случае мы называем функцию **методом**. В другом случае функции не относятся к чему-то конкретному и могут использоваться для различных типов объектов, например функция `len()`. Вот почему мы передаем `"Ola"` в качестве параметра функции `len`.

### Краткий обзор

OK, достаточно о строках. Пока ты узнала о:

*   **консоль** - ввод команд (кода) в интерактивную командную строку Python приводит к ответам на Python
*   **числа и строки** - в Python числа используются для вычислений, а строки - для текстовых объектов
*   **операторы** - такие как + и *, объединяют значения для получения нового
*   **функции** - такие как upper() и len(), выполняют действия над объектами.

Таковы основы каждого языка программирования, который ты можешь выучить. Готова к чему-то посложнее? Мы уверены, что готова!

## Ошибки

Давай попробуем кое-что новенькое. Можем ли мы получить длину числа так же, как длину твоего имени? Введи `len(304023)` и нажми `Enter`:

    >>> len(304023)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: object of type 'int' has no len()
    

Мы получили нашу первую ошибку! Она говорит о том, что у объектов типа «int» (целые числа) нет длины. Так что же мы можем сейчас сделать? Может быть мы можем написать наше число в виде строки? У строк ведь есть длина, верно?

    >>> len(str(304023))
    6
    

Сработало! Мы использовали функцию `str` внутри функции `len`. `str()` преобразует все в строки.

*   Функция `str` преобразует объекты в **строки**
*   Функция `int` преобразует объекты в **целые числа**

> Важно: мы можем преобразовать число в текст, но не всегда удается преобразовать текст в числа - например, каков будет результат `int('hello')`?

## Переменные

Переменные -- важное понятие в программировании. Переменная -- это не более чем имя для чего-то, чтобы использовать его позднее. Программисты используют переменные для хранения данных, чтобы их код был более читабельным, и для того, чтобы им не пришлось запоминать что есть что.

Допустим, мы хотим создать новую переменную с именем `name`:

    >>> name = "Ola"
    

Видишь? Это очень легко! Просто введи: name равно Ola.

Как ты уже заметила, твоя программа не возвращает ничего, как было ранее. Так откуда мы знаем, что переменная действительно существует? Просто введи `name` и нажми `Enter`:

    >>> name
    'Ola'
    

Ура! Твоя первая переменная:)! Ты всегда можешь изменить то, к чему она относится:

    >>> name = "Sonja"
    >>> name
    

Ты можешь использовать их также и в функциях:

    >>> len(name)
    5
    

Круто, правда? Переменными, конечно, может быть что угодно, и цифры тоже! Попробуй следующее:

    >>> a = 4
    >>> b = 6
    >>> a * b
    24
    

Но что делать, если мы использовали неправильное имя? Можешь догадаться, что произойдет? Давай попробуем!

    >>> city = "Tokyo"
    >>> ctiy
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'ctiy' is not defined
    

Ошибка! Как ты можешь видеть, в Python есть различные типы ошибок, эта называется **NameError**. Python выдаст эту ошибку при попытке использовать переменную, которая пока не определена. При возникновении этой ошибки проверь свой код, чтобы узнать, не написала ли ты неправильно имя переменной.

Попрактикуйся в этом какое-то время и посмотри, что ты сможешь сделать!

## Функция print

Попробуй ввести:

    >>> name = 'Maria'
    >>> name
    'Maria'
    >>> print(name)
    Maria
    

Если просто ввести `name`, интерпретатор Python вернет строковое *представление* переменной 'name', которым, в нашем случае, являются буквы M-a-r-i-a, окруженные одинарными кавычками, ''. Когда ты вводишь `print(name)`, Python "печатает" содержание переменной на экран, без кавычек, что удобнее.

Как мы увидим позднее, `print()` пригодится когда нам будет нужно печатать что-то изнутри функций или когда мы захотим напечатать что-то на нескольких строчках.

## Списки

Помимо строк и целых чисел Python имеет богатую коллекцию других типов объектов. Сейчас мы собираемся представить тебе один из них - **list** (список). Списки - это именно то, о чем ты подумала: объекты, которые являются списками других объектов :)

Давай начнем с создания списка:

    >>> []
    []
    

Отлично, это пустой список. Не особенно полезен, да? Давай создадим список лотерейных номеров. Мы не хотим повторять их каждый раз, так что присвоим список переменной:

    >>> lottery = [3, 42, 12, 19, 30, 59]
    

Замечательно, у нас есть список! Что мы можем с ним сделать? Для начала посмотрим как много лотерейных номеров в нашем списке. Есть идеи какую функцию можно использовать для этого? Ты её уже знаешь!

    >>> len(lottery)
    6
    

Точно! `len()` вернет тебе количество объектов в списке. Удобно, правда? Может быть мы теперь отсортируем его:

    >>> lottery.sort()
    

Эта команда не возвращает ничего, она просто меняет порядок номеров в списке. Давайте выведем его на экран и посмотрим что получилось:

    >>> print(lottery)
    [3, 12, 19, 30, 42, 59]
    

Как видишь, номера в списке теперь отсортированы от меньшего к большему. Поздравляем!

Может быть нам нужно изменить порядок? Давай сделаем это!

    >>> lottery.reverse()
    >>> print(lottery)
    [59, 42, 30, 19, 12, 3]
    

Просто, правда? Если хочешь добавить что-то к своему списку, то можешь воспользоваться этой командой:

    >>> lottery.append(199)
    >>> print(lottery)
    [59, 42, 30, 19, 12, 3, 199]
    

Если ты хочешь получить первый номер в списке, то можешь воспользоваться **индексами**. Индекс это номер позиции в списке, на котором находится нужное нам значение. Программисты предпочитают начать считать с 0, так что первому объекту в списке соответствует индекс 0, следующему —1, и так далее. Попробуй ввести:

    >>> print(lottery[0])
    59
    >>> print(lottery[1])
    42
    

Как видишь, ты можешь обратиться к различным объектам в своем списке используя имя списка и индекс объекта в квадратных скобках.

Чтобы удалить что-либо из списка, тебе понадобятся **индексы**, с которыми мы уже разобрались выше, и команда `pop()`. Давай попробуем закрепить пройденное примером; мы будем удалять первый элемент из нашего списка.

    >>> print(lottery)
    [59, 42, 30, 19, 12, 3, 199]
    >>> print(lottery[0])
    59
    >>> lottery.pop(0)
    >>> print(lottery)
    [42, 30, 19, 12, 3, 199]
    

Сработало как заклинание!

В качестве дополнительной тренировки попробуй следующие индексы: 6, 7, 1000, -1, -6 и -1000. Сможешь предсказать результат? Видишь логику работы?

Ты можешь найти перечень всех методов, относящихся к списку, в этой главе официальной документации Python: https://docs.python.org/3/tutorial/datastructures.html

## Словари

Словари схожи со списками, но ты обращаешься к значениям словаря по ключу, а не по индексу. Ключом может быть любая строка или число. Давай создадим пустой словарь:

    >>> {}
    {}
    

Это показывает, что мы создали пустой словарь. Ура!

Теперь попробуй следующую команду (можешь заменить значения на своё имя, страну и т.д.):

    >>> participant = {'name': 'Ola', 'country': 'Poland', 'favorite_numbers': [7, 42, 92]}
    

Этой командой ты создала переменную `participant` с тремя парами ключ-значение:

*   Ключ `name`, указывающий на значение `'Ola'` (`строковый` объект),
*   ключ `country`, указывающий на значение `'Poland'` (еще одна `строка`),
*   и ключ `favorite_numbers`, указывающий на значение `[7, 42, 92]` (объект типа `список` с тремя числами внутри).

Значение конкретного ключа можно узнать следующим образом:

    >>> print(participant['name'])
    Ola
    

Видишь, синтаксис похож на работу со списком. Но вместо того чтобы запоминать индекс, тебе нужно помнить ключ.

Что случится, если мы спросим у Python значение несуществующего в словаре ключа? Можешь предположить? Давай попробуем и узнаем наверняка!

    >>> participant['age']
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 'age'
    

Смотри, другая ошибка! Эта называется **KeyError**. Python услужливо напоминает, что ключа `'age'` не существует в словаре.

Когда стоит использовать словарь, а когда список? Это хороший вопрос для самостоятельного размышления. Сделай предположение перед тем, как читать дальше.

*   Тебе нужна упорядоченная последовательность элементов? Список - наш выбор.
*   Тебе нужны сочетания ключ - значение, чтобы быстро искать значения (по ключу) в дальнейшем? Словарь отлично подойдет.

Словари, как и списки, *изменяемы*, т. е. они могут быть изменены после того как были созданы. Ты можешь добавить новые пары ключ/значение в словарь следующим образом:

    >>> participant['favorite_language'] = 'Python'
    

Также как в примере со списками, использование функции `len()` вернет число пар ключ/значение в словаре. Попробуй сама:

    >>> len(participant)
    4
    

Надеюсь все вышеизложенное понятно. :) Готова к новым приключениям со словарями? На следующей строке тебя ждут изумительные вещи.

Ты можешь использовать команду `pop()` для удаления элементов из словаря. Скажем, ты хочешь удалить элемент с ключом `'favorite_numbers'`, просто набери следующую команду:

    >>> participant.pop('favorite_numbers')
    >>> participant
    {'country': 'Poland', 'favorite_language': 'Python', 'name': 'Ola'}
    

Как видно, пара ключ-значение с ключом 'favorite_numbers' была удалена.

Помимо этого, ты можешь заменить значение, ассоциированное с уже существующим ключом. Набери:

    >>> participant['country'] = 'Germany'
    >>> participant
    {'country': 'Germany', 'favorite_language': 'Python', 'name': 'Ola'}
    

Значение, на которое ссылается ключ `'country'` было изменено с `'Poland'` на `'Germany'`. :) Захватывает? Еще бы! Ты выучила еще одну потрясающую штуку.

### Содержание

Шикарно! Теперь ты знаешь немало о программировании. Мы познакомились с:

*   **ошибками** - теперь ты знаешь как читать и анализировать ошибки, которые возникают, если Python не понимает твоей команды
*   **переменными** - именами для объектов, которые упрощают твой код и делают его более читабельным
*   **списками** - последовательностями объектов в заданном порядке
*   **словарями** - объектами, хранящими пары ключ-значение

Готова к продолжению? :)

## Сравниваем вещи

Немалая часть программирования требует сравнения вещей. Что проще всего сравнить друг с другом? Числа, конечно. Давай посмотрим как это работает:

    >>> 5 > 2
    True
    >>> 3 < 1
    False
    >>> 5 > 2 * 2
    True
    >>> 1 == 1
    True
    >>> 5 != 2
    True
    

Мы передали Python несколько чисел для сравнения. Как ты можешь заметить, Python сравнивает не только числа, но и результаты методов (например, умножения). Неплохо, правда?

Хочешь спросить почему мы написал двойной символ равенства `==`, чтобы проверить одинаковы ли числа? Потому что одинарные символ равенства `=` уже задействован под присваивание значения переменным. Ты всегда, **всегда** должна писать два символа равенства `==`, если хочешь проверить одинаковы ли объекты. Мы также можем проверить различаются ли объекты. Для этого, мы используем `!=`, как показано в примере выше.

Дадим Python еще два задания:

    >>> 6 >= 12 / 2
    True
    >>> 3 <= 2
    False
    

С `>` и `<` все понятно, но что значат `>=` и `<=`? Читай их следующим образом:

*   x `>` y означает: x больше y
*   x `<` y означает: x меньше y
*   x `<=` y означает: x меньше или равен y
*   x `>=` y означает: x больше или равен y

Супер! Хочешь еще? Тогда попробуй вот это:

    >>> 6 > 2 and 2 < 3
    True
    >>> 3 > 2 and 2 < 1
    False
    >>> 3 > 2 or 2 < 1
    True
    

Ты можешь передать Python так много чисел, как захочешь, и он будет возвращать ответ! Хитро, правда?

*   **and** - если ты используешь `and` оператор, оба сравнения по бокам от него должны быть True (верны), чтобы результат всей команды был равен True
*   **or** - если ты используешь `or` оператор, достаточно одному из сравнений по бокам от него быть равным True, чтобы результат всей команды также равнялся True

Ты когда-нибудь слышала выражение "сравнивать яблоки и апельсины"? Попробуем что-то подобное в Python:

    >>> 1 > 'django'
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unorderable types: int() > str()
    

Как мы видим, Python не знает как сравнить число (`int`) и строку (`str`) между собой. Поэтому он просто возвращает нам ошибку **TypeError** и предупреждает, что объекты заданных типов не могут быть сравнены.

## Логические значения

Между прочим, ты только что познакомилась с новым типом объектов в Python. Он называется **Boolean** (логический) -- и это наверно самый простой тип из всех.

Существует только два логических объекта в Python: - True (Истина) - False (Ложь)

Чтобы Python понимал тебя, ты всегда должна писать True с заглавной буквы (остальные прописные). **true, TRUE, tRUE не будет восприниматься -- только True.** (Та же логика применима к False, само собой.)

Ты можешь присваивать переменным логические значения! Смотри сюда:

    >>> a = True
    >>> a
    True
    

Или так:

    >>> a = 2 > 5
    >>> a
    False
    

Попрактикуйся с логическими значениями на примере этих выражений:

*   `True and True`
*   `False and True`
*   `True or 1 == 1`
*   `1 != 2`

Поздравляем! Логические значения одна из самых классных фишек программирования и ты только что научилась ими пользоваться!

# Сохраняй!

До сих пор мы писали весь код в интерактивной консоли, где Python сразу анализировал, обрабатывал и выполнял наши команды. Мы были ограничены одной строкой. Обычно, программы сохраняются в файлах и выполняются **интерпретатором** или **компилятором** нашего языка программирования. Пока мы только просили **интерпретатор** Python выполнять наши однострочные команды из консоли. Однако, нам понадобиться больше места для следующих задач, поэтому задача минимум:

*   Закрыть интерактивную консоль Python
*   Открыть наш текстовый редактор
*   Сохранить код в новом файле
*   Запустить его!

Чтобы закрыть интерактивную консоль Python просто набери функцию `exit()` :

    >>> exit()
    $
    

Это вернет тебя в командную строку.

В главе [Текстовый редактор][2] мы выбрали себе редактор. Нам нужно открыть его сейчас и записать следующий код в новый файл:

 [2]: ../code_editor/README.md

```python
print('Hello, Django girls!')
```
    

> **Примечание** Ты должна уже была заметить одну из крутейших вещей в редакторах кода: цвета! В интерактивной консоли Python весь текст был одного цвета, сейчас же функция `print` должна отличаться по цвету от текста, который передается в неё в качестве атрибута. Это называется «синтаксическая подсветка», и это действительно удобная штука для программирования. Цвет подсветки может подсказать тебе о незакрытой кавычке или опечатке в ключевом слове (таком как `def` в определении функции, с которым мы скоро познакомимся). Это одна из причин, по которой мы используем редакторы кода :)

Очевидно, ты уже искушенный Python разработчик, так что не стесняйся добавить что-нибудь по своему вкусу из ранее изученного.

Теперь нам нужно сохранить файл с кодом и дать ему подходящее имя. Давай назовем его **python_intro.py** и сохраним на рабочий стол. Мы можем назвать файл как хотим, но важно чтобы название заканчивалось на **.py**. Расширение **.py** говорит операционной системе, что это **исполняемый файл python**, и Python может его запустить.

После сохранения файла пришло время запустить его! Используя навыки из раздела о командной строке, открой терминал и **поменяй текущую директорию** на рабочий стол.

Для Mac команда будет выглядеть так:

    $ cd /Users/<your_name>/Desktop
    

Для Linux (слово "Desktop" может быть переведено на твой язык, например "Рабочий стол"):

    $ cd /home/<your_name>/Desktop
    

И для windows:

    > cd C:\Users\<your_name>\Desktop
    

Если возникли проблемы - просто обратись за помощью.

Теперь используй Python чтобы запустить код в файле:

    $ python3 python_intro.py
    Hello, Django girls!
    

Отлично! Ты только что запустила свою первую программу, чей код был сохранен в файле. Чувствуешь воодушевление?

Можно передвигаться дальше к такому незаменимому в программировании инструменту как:

## If...elif...else

Зачастую определенный код в программе должен выполняться только при соблюдении определенных условий. Поэтому в Python есть такая вещь как **условный оператор if**.

Замени код в своем файле **python_intro.py** на:

```python
if 3 > 2:
```
    

Если мы сохраним его и запустим, то получим ошибку:

    $ python3 python_intro.py
    File "python_intro.py", line 2
             ^
    SyntaxError: unexpected EOF while parsing
    

Python предполагает, что мы должны дать ему инструкции, которые будут им выполнены при соблюдении условия `3 > 2` (т. е. при равенстве условия логическому значению `True`). Давай попробуем заставить Python напечатать на экране “It works!”. Внеси следующие изменения в **python_intro.py**:

```python
if 3 > 2:
    print('It works!')
```
    

Обратила внимание как мы сделали отступ во второй строке из 4 символов пробела? Мы поступаем так, чтобы Python понимал какой код после условного оператора if должен быть выполнен, если условие равно True. Можно ограничиться и одним пробелом, однако, практически все программисты Python используют 4, чтобы код выглядел аккуратно и читабельно. Каждая `табуляция` также считается за 4 пробела.

Сохраняем и запускаем еще раз:

    $ python3 python_intro.py
    It works!
    

### Что, если условие не True?

В предыдущем примере код выполнялся только когда условие равнялось True. Однако, Python имеет операторы `elif` и `else`:

```python
if 5 > 2:
    print('5 is indeed greater than 2')
else:
    print('5 is not greater than 2')
```
    

Если запустить этот код, он напечатает:

    $ python3 python_intro.py
    5 is indeed greater than 2
    

Если 2 больше 5, то будет выполнена следующая команда. Просто, правда? Давай посмотрим как работает оператор `elif`:

```python
name = 'Sonja'
if name == 'Ola':
    print('Hey Ola!')
elif name == 'Sonja':
    print('Hey Sonja!')
else:
    print('Hey anonymous!')
```
    

и запускаем:

    $ python3 python_intro.py
    Hey Sonja!
    

Видишь, что произошло? `elif` позволяет добавить дополнительные условия, которые запускаются если предыдущие не срабатывают.

Можно использовать сколько угодно `elif` после первого `if`. Например:

```python
volume = 57
if volume < 20:
    print("It's kinda quiet.")
elif 20 <= volume < 40:
    print("It's nice for background music")
elif 40 <= volume < 60:
    print("Perfect, I can hear all the details")
elif 60 <= volume < 80:
    print("Nice for parties")
elif 80 <= volume < 100:
    print("A bit loud!")
else:
    print("My ears are hurting! :(")
```
    

Python проходит через каждую проверку условия и выводит:

    $ python3 python_intro.py
    Perfect, I can hear all the details
    

### Содержание

В последних трех упражнениях ты познакомилась с:

*   **сравнением вещей** - в Python ты можешь сравнивать вещи друг с другом при помощи `>`, `>=`, `==`, `<=`, `<` и `and`, `or` операторов
*   **Boolean** - тип объекта, который может иметь только два значения: `True` или `False`
*   **сохранением файлов** - хранение кода в файлах позволяет выполнять длинные программы.
*   **if...elif...else** - условные операторы, которые позволяют выполнять код только при определенных условиях.

Пришло время для последней части этой главы!

## Твоя собственная функция!

Помнишь функции, такие как `len()`, которые можно использовать в Python? Тогда у нас есть хорошие новости — сейчас ты научишься писать свои собственные функции!

Функция - это последовательность инструкций, которые должен выполнить Python. Каждая функция в Python начинается с ключевого слова `def`, имеет свое имя и параметры. Давай начнем с простого примера. Замени код в **python_intro.py** на следующий:

```python
def hi():
    print('Hi there!')
    print('How are you?')

hi()
```
    

Отлично, наша первая функция готова!

Ты можешь задаться вопросом, почему мы написали имя функции в конце файла. Причина в том, что Python читает и исполняет код из файла сверху вниз. Поэтому, для использования нашей функции мы должны вызвать её в конце файла.

Давай запустим и посмотрим что произойдет:

    $ python3 python_intro.py
    Hi there!
    How are you?
    

Это было просто! Давай напишем нашу первую функцию с параметрами. Мы будем использовать предыдущий пример - функцию, которая пишут 'hi' и имя пользователя:

```python
def hi(name):
```
    

Как ты можешь заметить, мы передали нашей функции параметр `name`:

```python
def hi(name):
    if name == 'Ola':
        print('Hi Ola!')
    elif name == 'Sonja':
        print('Hi Sonja!')
    else:
        print('Hi anonymous!')

hi()
```
    

Помни: функция `print` расположена внутри блока оператора `if` с отступом в четыре пробела. Это потому, что она запускается тогда, когда выполняется условие. Давай посмотрим, как это работает:

    $ python3 python_intro.py
    Traceback (most recent call last):
    File "python_intro.py", line 10, in <module>
      hi()
    TypeError: hi() missing 1 required positional argument: 'name'
    

Упс, ошибка. К счастью, Python выдает довольно подробное сообщение об ошибке. Оно говорит нам, что функция `hi()` (которую мы определили) имеет один обязательный аргумент (`name`) и мы забыли передать его при вызове функции. Давай исправим это в конце файла:

```python
hi("Ola")
```
    

И запустим еще раз:

    $ python3 python_intro.py
    Hi Ola!
    

И если мы поменяем имя?

```python
hi("Sonja")
```
    

И повторим:

    $ python3 python_intro.py
    Hi Sonja!
    

Теперь, как ты думаешь, что произойдет, если ты наберешь другое имя? (Не Ola или Sonja) Попробуй сама и проверь была ли ты права. Результат должен быть таким:

    Hi anonymous!
    

Шикарно, верно? Так тебе не придется повторяться каждый раз, когда ты захочешь изменить имя. И это именно та причина, для которой нам и нужны функции - ты никогда не захочешь повторять свой код!

Давай попробуем что-то похитрее -- существует немало имен и писать условие для каждого будет тяжело, правда?

```python
def hi(name):
    print('Hi ' + name + '!')

hi("Rachel")
```
    

Давай выполним этот код:

    $ python3 python_intro.py
    Hi Rachel!
    

Поздравляем! Ты только что научилась писать свои собственные функции :)

## Циклы

Ну вот и последняя часть. Быстро время пролетело, верно? :)

Программисты не любят повторяться. Программирование — это автоматизация вещей, поэтому мы не хотим приветствовать каждого человека по имени вручную, верно? Здесь пригодятся циклы.

Еще помнишь о списках? Давай создадим список девушек:

```python
girls = ['Rachel', 'Monica', 'Phoebe', 'Ola', 'You']
```
    

Мы хотим поздороваться с каждой по имени. У нас есть функция `hi`, которая этим и занимается, так что давай поместим её в цикл:

```python
for name in girls:
```
    

Оператор `for` работает по схожему принципу что и `if`; код после обоих операторов должен иметь отступ в четыре пробела.

Ниже полный код, который должен быть у нас в файле:

```python
def hi(name):
    print('Hi ' + name + '!')

girls = ['Rachel', 'Monica', 'Phoebe', 'Ola', 'You']
for name in girls:
    hi(name)
    print('Next girl')
```
    

И после запуска:

    $ python3 python_intro.py
    Hi Rachel!
    Next girl
    Hi Monica!
    Next girl
    Hi Phoebe!
    Next girl
    Hi Ola!
    Next girl
    Hi You!
    Next girl
    

Как ты можешь заметить, все команды внутри цикла `for` (с отступом от левого края) будут выполняться для каждого элемента списка `girls`.

Ты также можешь использовать цикл `for` на числах, используя функцию `range`:

```python
for i in range(1, 6):
    print(i)
```
    

Что выведет на экран:

```
1
2
3
4
5
```
    

Функция `range` создает список чисел, следующих от первого до второго с заданным шагом (начало, конец и шаг мы передаем функции как параметры, если шаг не указать, как в примере выше, он будет по умолчанию равен 1).

Обрати внимание что второе число (конец списка) не включается в результат работы функции (`range(1, 6)` создает список от 1 до 5, не включающий 6). Это потому, что «range» — полуоткрытый диапазон, то есть включает в себя первое значение, но не включает последнего.

## Содержание

Вот и всё. **Ты чертовски крута!** Эта глава была непростой, так что ты можешь гордиться собой. Мы-то точно тобой гордимся — вон как далеко продвинулась уже!

Тебе может потребоваться перерыв - прогуляйся и дай отдых глазам перед тем, как мы перейдем к следующей главе. :)

![Пирожок][3]

 [3]: images/cupcake.png
