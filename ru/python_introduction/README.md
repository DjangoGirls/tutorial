# Введение в Python

> Часть этой главы основана на учебных пособиях Geek Girls Carrots (https://github.com/ggcarrots/django-carrots).

Давай напишем немного кода!

## Консоль Python

> Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: Integers, Strings, Lists, Variables and Errors](https://www.youtube.com/watch?v=MO63L4s-20U).

Чтобы начать играть с Python, нам нужно открыть *командную строку* на твоём компьютере. Ты уже должна знать, как это сделать — мы изучали это в главе [Введение в интерфейс командой строки][1].

 [1]: ../intro_to_command_line/README.md

Когда будешь готова, следуй приведенным ниже инструкциям.

Мы хотим открыть консоль Python, так что набери `python`, если работаешь в Windows, или `python3` для Mac OS/Linux, и нажми `enter`.

{% filename %}command-line{% endfilename %}
```
$ python3
Python 3.6.1 (...)
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

## Твоя первая команда Python!

После запуска Python командная строка изменилась на `>>>`. Для нас это означает, что сейчас мы можем использовать только команды на языке Python. Тебе не нужно вводить `>>>` — Python будет делать это за нас.

Если ты хочешь выйти из консоли Python, в любой момент — просто введи `exit()` или используй сочетание клавиш `Ctrl + Z` для Windows и `Ctrl + D` для Mac/Linux. Тогда ты больше не будешь видеть `>>>`.

Пока что мы не хотим выходить из консоли Python. Мы хотим узнать больше о ней. Давай начнём с чего-нибудь совсем простого. Например, попробуй набрать простое математическое выражение, вроде `2 + 3`, и нажми `enter`.

{% filename %}command-line{% endfilename %}
```python
>>> 2 + 3
5
```

Прекрасно! Видишь, как выскочил ответ? Python знает математику! Ты можешь попробовать другие команды, например:

- `4 * 5`
- `5 - 1`
- `40 / 2`

Чтобы вычислить степень числа, например, 2 в кубе, мы вводим:
{% filename %}command-line{% endfilename %}
```python
>>> 2 ** 3
8
```

Поиграй с этим немного и затем вернись сюда :).

Как видишь, Python является прекрасным калькулятором. Если тебе интересно, что ещё можно сделать...

## Строки

Как насчет твоего имени? Введи своё имя в кавычках, вот так:

{% filename %}command-line{% endfilename %}
```python
>>> "Ola"
'Ola'
```

Ты только что создала свою первую строку! Это последовательность символов, которые могут быть обработаны компьютером. Строка должна всегда начинаться и заканчиваться одинаковым символом. Им может быть одинарная (`'`) или двойная (`"`) кавычка (разницы нет!) Кавычки говорят Python'у, что внутри них находится строка.

Строки могут быть слиты воедино. Попробуй так:

{% filename %}command-line{% endfilename %}
```python
>>> "Hi there " + "Ola"
'Hi there Ola'
```

Ты также можешь умножать строки на число:

{% filename %}command-line{% endfilename %}
```python
>>> "Ola" * 3
'OlaOlaOla'
```

Если тебе нужно поставить апостроф внутри строки, то есть два способа сделать это.

Используй двойные кавычки:

{% filename %}command-line{% endfilename %}
```python
>>> "Runnin' down the hill"
"Runnin' down the hill"
```

или поставь перед апострофом обратную косую черту (`\`):

{% filename %}command-line{% endfilename %}
```python
>>> 'Runnin\' down the hill'
"Runnin' down the hill"
```

Прикольно, да? Чтобы увидеть своё имя прописными буквами, просто набери:

{% filename %}command-line{% endfilename %}
```python
>>> "Ola".upper()
'OLA'
```

Ты только что использовала __метод__ `upper` своей строки! Метод (такой как `upper()`) представляет собой набор инструкций, который должен выполнить Python над заданным объектом (в нашем случае: `"Ola"`) при его вызове.

Если ты хочешь узнать количество букв в своём имени, то и для этого тоже существует функция!

{% filename %}command-line{% endfilename %}
```python
>>> len("Ola")
3
```

Интересно, почему иногда мы вызываем функцию добавлением `.` к концу строки (как `"Ola".upper()`), а иногда сначала пишем имя функции и затем помещаем строку в скобки? Ну, в некоторых случаях функции принадлежат объектам, например, функция `upper()`, которая может быть применена только к строкам. В этом случае мы называем функцию __методом__. В другом случае функции не относятся к чему-то конкретному и могут использоваться для различных типов объектов, например, функция `len()`. Вот почему мы передаем `"Ola"` в качестве параметра функции `len`.

### Подведём итог

Хорошо, достаточно о строках. Пока ты узнала следующее:

*   __командная строка__ — ввод команд (кода) в интерактивную командную строку Python приводит к ответам на Python;
*   __числа и строки__ — в Python числа используются для вычислений, а строки - для текстовых объектов;
*   __операторы__, такие как + и *, объединяют значения для получения нового;
*   __функции__, такие как upper() и len(), выполняют действия над объектами.

Таковы основы каждого языка программирования, который ты можешь выучить. Готова к чему-то посложнее? Мы уверены, что готова!

## Ошибки

Давай попробуем кое-что новенькое. Можем ли мы получить длину числа так же, как длину твоего имени? Введи `len(304023)` и нажми `Enter`:

{% filename %}command-line{% endfilename %}
```python
>>> len(304023)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'int' has no len()
```

Мы получили нашу первую ошибку! Она говорит о том, что у объектов типа «int» (целые числа) нет длины. Так что же мы можем сейчас сделать? Может быть, мы можем написать наше число в виде строки? У строк ведь есть длина, верно?

{% filename %}command-line{% endfilename %}
```python
>>> len(str(304023))
6
```

Сработало! Мы использовали функцию `str` внутри функции `len`. `str()` преобразует всё в строки.

-   Функция `str` преобразует объекты в __строки__
-   Функция `int` преобразует объекты в __целые числа__

> Важно: мы можем преобразовать число в текст, но не всегда удается преобразовать текст в числа — например, каков будет результат `int('hello')`?

## Переменные

Переменные — важное понятие в программировании. Переменная — это всего лишь имя для чего-то, чтобы использовать его позднее. Программисты используют переменные для хранения данных, чтобы их код был более читабельным, и для того, чтобы им не пришлось запоминать что есть что.

Допустим, мы хотим создать новую переменную с именем `name`:

{% filename %}command-line{% endfilename %}
```python
>>> name = "Ola"
```

Видишь? Это очень легко! Просто введи: name равно Ola.

Как ты уже заметила, твоя программа не возвращает ничего, как было ранее. Так откуда мы знаем, что переменная действительно существует? Просто введи `name` и нажми `Enter`:

{% filename %}command-line{% endfilename %}
```python
>>> name
'Ola'
```

Ура! Твоя первая переменная:)! Ты всегда можешь изменить то, к чему она относится:

{% filename %}command-line{% endfilename %}
```python
>>> name = "Sonja"
>>> name
'Sonja'
```

Ты также можешь использовать переменные и в функциях:

{% filename %}command-line{% endfilename %}
```python
>>> len(name)
5
```

Круто, правда? Переменными, конечно, может быть что угодно, и цифры тоже! Попробуй следующее:

{% filename %}command-line{% endfilename %}
```python
>>> a = 4
>>> b = 6
>>> a * b
24
```

Но что делать, если мы использовали неправильное имя? Можешь догадаться, что произойдет? Давай попробуем!

{% filename %}command-line{% endfilename %}
```python
>>> city = "Tokyo"
>>> ctiy
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'ctiy' is not defined
```

Ошибка! Как ты можешь видеть, в Python есть различные типы ошибок, эта называется **NameError**. Python выдаст эту ошибку при попытке использовать переменную, которая пока не определена. При возникновении этой ошибки проверь свой код, чтобы узнать, не написала ли ты неправильно имя переменной.

Попрактикуйся в этом какое-то время и посмотри, что ты сможешь сделать!

## Функция print

Попробуй ввести:

{% filename %}command-line{% endfilename %}
```python
>>> name = 'Maria'
>>> name
'Maria'
>>> print(name)
Maria
```

Если просто ввести `name`, интерпретатор Python вернет строковое *представление* переменной 'name', которым, в нашем случае, являются буквы M-a-r-i-a, окруженные одинарными кавычками, ''. Когда ты вводишь `print(name)`, Python "печатает" содержание переменной на экран, без кавычек, что удобнее.

Как мы увидим позднее, `print()` пригодится, когда нам будет нужно печатать что-то изнутри функций или когда мы захотим напечатать что-то на нескольких строчках.

## Списки

Помимо строк и целых чисел Python имеет богатую коллекцию других типов объектов. Сейчас мы собираемся представить тебе один из них — **list** (список). Списки — это именно то, о чём ты подумала: объекты, которые являются списками других объектов :)

Давай начнем с создания списка:

{% filename %}command-line{% endfilename %}
```python
>>> []
[]
```

Отлично, это пустой список. Не особенно полезен, да? Давай создадим список лотерейных номеров. Мы не хотим повторять их каждый раз, так что присвоим список переменной:

{% filename %}command-line{% endfilename %}
```python
>>> lottery = [3, 42, 12, 19, 30, 59]
```

Замечательно, у нас есть список! Что мы можем с ним сделать? Для начала посмотрим, как много лотерейных номеров в нашем списке. Есть идеи, какую функцию можно использовать для этого? Ты её уже знаешь!

{% filename %}command-line{% endfilename %}
```python
>>> len(lottery)
6
```

Точно! `len()` вернет тебе количество объектов в списке. Удобно, правда? Пожалуй, мы теперь отсортируем его:

{% filename %}command-line{% endfilename %}
```python
>>> lottery.sort()
```

Эта команда не возвращает ничего, она просто меняет порядок номеров в списке. Давайте выведем его на экран и посмотрим, что получилось:

{% filename %}command-line{% endfilename %}
```python
>>> print(lottery)
[3, 12, 19, 30, 42, 59]
```

Как видишь, номера в списке теперь отсортированы от меньшего к большему. Поздравляем!

Может, нам нужно обратить порядок? Давай сделаем это!

{% filename %}command-line{% endfilename %}
```python
>>> lottery.reverse()
>>> print(lottery)
[59, 42, 30, 19, 12, 3]
```

Просто, правда? Если хочешь добавить что-то к своему списку, то можешь воспользоваться этой командой:

{% filename %}command-line{% endfilename %}
```python
>>> lottery.append(199)
>>> print(lottery)
[59, 42, 30, 19, 12, 3, 199]
```

Если ты хочешь получить только первый номер в списке, то можешь воспользоваться **индексами**. Индекс — это номер позиции в списке, на котором находится нужное нам значение. Программисты предпочитают начать считать с 0, так что первому объекту в списке соответствует индекс 0, следующему —1, и так далее. Попробуй ввести:

{% filename %}command-line{% endfilename %}
```python
>>> print(lottery[0])
59
>>> print(lottery[1])
42
```

Как видишь, ты можешь обратиться к различным объектам в своем списке используя имя списка и индекс объекта в квадратных скобках.

Чтобы удалить что-либо из списка, тебе понадобятся **индексы**, с которыми мы уже разобрались выше, и команда `pop()`. Давай попробуем закрепить пройденное на примере: мы будем удалять первый элемент из нашего списка.

{% filename %}command-line{% endfilename %}
```python
>>> print(lottery)
[59, 42, 30, 19, 12, 3, 199]
>>> print(lottery[0])
59
>>> lottery.pop(0)
59
>>> print(lottery)
[42, 30, 19, 12, 3, 199]
```

Сработало как заклинание!

В качестве дополнительной тренировки попробуй следующие индексы: 6, 7, 1000, -1, -6 и -1000. Можешь предсказать результат? Видишь логику работы?

Ты можешь найти перечень всех методов, относящихся к списку, в этой главе официальной документации Python: https://docs.python.org/3/tutorial/datastructures.html

## Словари

> Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: Dictionaries](https://www.youtube.com/watch?v=ZX1CVvZLE6c).

Словари схожи со списками, но ты обращаешься к значениям словаря по ключу, а не по индексу. Ключом может быть любая строка или число. Давай создадим пустой словарь:

{% filename %}command-line{% endfilename %}
```python
>>> {}
{}
```

Это показывает, что мы создали пустой словарь. Ура!

Теперь попробуй следующую команду (можешь заменить значения на своё имя, страну и т.д.):

{% filename %}command-line{% endfilename %}
```python
>>> participant = {'name': 'Ola', 'country': 'Poland', 'favorite_numbers': [7, 42, 92]}
```

Этой командой ты создала переменную `participant` с тремя парами ключ/значение:

-   ключ `name`, указывающий на значение `'Ola'` (объект типа `строка`),
-   ключ `country`, указывающий на значение `'Poland'` (еще одна `строка`),
-   и ключ `favorite_numbers`, указывающий на значение `[7, 42, 92]` (объект типа `список` с тремя числами внутри).

Значение конкретного ключа можно узнать следующим образом:

{% filename %}command-line{% endfilename %}
```python
>>> print(participant['name'])
Ola
```

Видишь, синтаксис похож на работу со списком. Но вместо того, чтобы запоминать индекс, тебе нужно помнить ключ.

Что случится, если мы спросим у Python значение несуществующего в словаре ключа? Можешь предположить? Давай попробуем и узнаем наверняка!

{% filename %}command-line{% endfilename %}
```python
>>> participant['age']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'age'
```

Смотри, другая ошибка! Эта называется **KeyError**. Python услужливо напоминает, что ключа `'age'` нет в словаре.

Когда стоит использовать словарь, а когда список? Это хороший вопрос для самостоятельного размышления. Сделай предположение перед тем, как читать дальше.

-   Тебе нужна упорядоченная последовательность элементов? Список — наш выбор.
-   Тебе нужны сочетания ключ/значение, чтобы быстро искать значения (по ключу) в дальнейшем? Словарь отлично подойдет.

Словари, как и списки, *изменяемы*, т. е. они могут быть изменены после того как были созданы. Ты можешь добавить новые пары ключ/значение в словарь следующим образом:

{% filename %}command-line{% endfilename %}
```python
>>> participant['favorite_language'] = 'Python'
```

Так же как в примере со списками, использование функции `len()` вернёт число пар ключ/значение в словаре. Попробуй сама:

{% filename %}command-line{% endfilename %}
```python
>>> len(participant)
4
```

Надеюсь, всё вышеизложенное понятно. :) Готова к новым приключениям со словарями? На следующей строке тебя ждут изумительные вещи.

Ты можешь использовать команду `pop()` для удаления элементов из словаря. Скажем, ты хочешь удалить элемент с ключом `'favorite_numbers'`. Просто набери следующую команду:

{% filename %}command-line{% endfilename %}
```python
>>> participant.pop('favorite_numbers')
[7, 42, 92]
>>> participant
{'country': 'Poland', 'favorite_language': 'Python', 'name': 'Ola'}
```

Как видишь, пара ключ/значение с ключом 'favorite_numbers' была удалена.

Помимо этого, ты можешь заменить значение, связанное с уже существующим ключом. Набери:

{% filename %}command-line{% endfilename %}
```python
>>> participant['country'] = 'Germany'
>>> participant
{'country': 'Germany', 'favorite_language': 'Python', 'name': 'Ola'}
```


Значение, на которое ссылается ключ `'country'`, изменилось с `'Poland'` на `'Germany'`. :) Захватывает? Ещё бы! Ты выучила еще одну потрясающую штуку!

### Подведём итог

Шикарно! Теперь ты знаешь немало о программировании. Мы познакомились с:

*   __ошибками__ — теперь ты знаешь как читать и анализировать ошибки, которые возникают, если Python не понимает твоей команды;
*   __переменными__ — именами для объектов, которые упрощают твой код и делают его более читабельным;
*   __списками__ — последовательностями объектов в заданном порядке;
*   __словарями__ — объектами, хранящими пары ключ/значение.

Готова к продолжению? :)

## Сравнение вещей

> Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: Comparisons](https://www.youtube.com/watch?v=7bzxqIKYgf4).

Немалая часть программирования требует сравнения вещей. Что проще всего сравнить друг с другом? Числа, конечно. Давай посмотрим, как это работает:

{% filename %}command-line{% endfilename %}
```python
>>> 5 > 2
True
>>> 3 < 1
False
>>> 5 > 2 * 2
True
>>> 1 == 1
True
>>> 5 != 2
True
```

Мы передали Python несколько чисел для сравнения. Как ты можешь заметить, Python сравнивает не только числа, но и результаты методов (например, умножения). Неплохо, правда?

Хочешь спросить, почему мы написал двойной символ равенства `==`, чтобы проверить, одинаковы ли числа? Потому что одинарные символ равенства `=` уже задействован под присваивание значения переменным. Ты всегда, __всегда__ должна писать два символа равенства `==`, если хочешь проверить, одинаковы ли объекты. Мы также можем проверить, различаются ли объекты. Для этого мы используем `!=`, как показано в примере выше.

Дадим Python еще два задания:

{% filename %}command-line{% endfilename %}
```python
>>> 6 >= 12 / 2
True
>>> 3 <= 2
False
```

С `>` и `<` все понятно, но что значат `>=` и `<=`? Читай их следующим образом:

-   x `>` y означает: x больше y
-   x `<` y означает: x меньше y
-   x `<=` y означает: x меньше или равен y
-   x `>=` y означает: x больше или равен y

Супер! Хочешь еще? Тогда попробуй вот это:

{% filename %}command-line{% endfilename %}
```python
>>> 6 > 2 and 2 < 3
True
>>> 3 > 2 and 2 < 1
False
>>> 3 > 2 or 2 < 1
True
```

Ты можешь передать Python столько чисел, сколько захочешь, и он будет возвращать ответ! Хитро, правда?

-   __and__ — если ты используешь оператор `and`, оба сравнения по бокам от него должны быть True (верны), чтобы результат всей команды был равен True.
-   __or__ — если ты используешь оператор `or`, достаточно одному из сравнений по бокам от него быть равным True, чтобы результат всей команды также равнялся True.

Ты когда-нибудь слышала выражение "сравнивать яблоки с апельсинами"? Попробуем сделать что-то подобное в Python:

{% filename %}command-line{% endfilename %}
```python
>>> 1 > 'django'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '>' not supported between instances of 'int' and 'str'
```

Как мы видим, Python не знает, как сравнить число (`int`) и строку (`str`) между собой. Поэтому он просто возвращает нам ошибку **TypeError** и предупреждает, что объекты заданных типов не могут быть сравнены.

## Логические значения

Между прочим, ты только что познакомилась с новым типом объектов в Python. Он называется __Boolean__ (логический) — и это, наверное, самый простой тип из всех.

Существует только два логических объекта в Python:
- True (Истина),
- False (Ложь).

Чтобы Python понимал тебя, ты всегда должна писать True с заглавной буквы (остальные прописные). **true, TRUE, tRUE не будет восприниматься — только True.** (Та же логика применима к False, само собой.)

Ты можешь присваивать переменным логические значения! Смотри сюда:

{% filename %}command-line{% endfilename %}
```python
>>> a = True
>>> a
True
```

Или так:

{% filename %}command-line{% endfilename %}
```python
>>> a = 2 > 5
>>> a
False
```

Попрактикуйся с логическими значениями на примере этих выражений:

-   `True and True`
-   `False and True`
-   `True or 1 == 1`
-   `1 != 2`

Поздравляем! Логические значения — одна из самых классных фишек программирования, и ты только что научилась ими пользоваться!

# Сохраняй!

> Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: Saving files and "If" statement](https://www.youtube.com/watch?v=dOAg6QVAxyk).

До сих пор мы писали весь код в интерактивной консоли, где Python сразу анализировал, обрабатывал и выполнял наши команды. Мы были ограничены одной строкой. Обычно, программы сохраняются в файлах и выполняются **интерпретатором** или **компилятором** нашего языка программирования. Пока мы только просили **интерпретатор** Python выполнять наши однострочные команды из консоли. Однако нам понадобиться больше места для следующих задач, поэтому задача минимум:

- закрыть интерактивную консоль Python;
- открыть наш текстовый редактор;
- сохранить код в новом файле;
- запустить его!

Чтобы закрыть интерактивную консоль Python, просто набери функцию `exit()`:

{% filename %}command-line{% endfilename %}
```python
>>> exit()
$
```

Это вернёт тебя в командную строку.

В главе [Текстовый редактор][2] мы выбрали себе редактор. Нам нужно открыть его сейчас и записать следующий код в новый файл:

 [2]: ../code_editor/README.md

{% filename %}editor{% endfilename %}
```python
print('Hello, Django girls!')
```

Очевидно, ты уже искушенный Python разработчик, так что не стесняйся добавить что-нибудь по своему вкусу из ранее изученного.

Теперь нам нужно сохранить файл с кодом и дать ему подходящее имя. Давай назовем его **python_intro.py** и сохраним на рабочий стол. Мы можем назвать файл как хотим, но важно, чтобы название заканчивалось на **.py**. Расширение **.py** говорит операционной системе, что это **исполняемый файл python**, и Python может его запустить.

> **Примечание** Ты должна уже была заметить одну из крутейших вещей в редакторах кода: цвета! В интерактивной консоли Python весь текст был одного цвета, сейчас же функция `print` должна отличаться по цвету от текста, который передается в неё в качестве аргумента. Это называется «синтаксическая подсветка», и это действительно удобная штука для программирования. Цвет подсветки может подсказать тебе о незакрытой кавычке или опечатке в ключевом слове (таком как `def` в определении функции, с которым мы скоро познакомимся). Это одна из причин, по которой мы используем редакторы кода :)


После сохранения файла пришло время запустить его! Используя навыки из раздела о командной строке, открой терминал и **поменяй текущую директорию** на рабочий стол.

<!--sec data-title="OS X" data-id="python_OSX"
data-collapse=true ces-->

Для Mac команда будет выглядеть так:

{% filename %}command-line{% endfilename %}
```
$ cd ~/Desktop
```
<!--endsec-->

<!--sec data-title="Linux" data-id="python_linux"
data-collapse=true ces-->

Для Linux (слово "Desktop" может быть переведено на твой язык, например "Рабочий стол"):

{% filename %}command-line{% endfilename %}
```
$ cd ~/Desktop
```

<!--endsec-->

<!--sec data-title="Командная строка Windows" data-id="python_windows" data-collapse=true ces-->

В командной строке Windows команда будет такой:

{% filename %}command-line{% endfilename %}
```
> cd %HomePath%\Desktop
```
<!--endsec-->


<!--sec data-title="Windows Powershell" data-id="python_windowsPSH" data-collapse=true ces-->

В Windows Powershell команда будет такой:

{% filename %}command-line{% endfilename %}
```
> cd $Home\Desktop
```
<!--endsec-->


Если возникли проблемы — просто обратись за помощью.

Теперь используй Python, чтобы запустить код в файле:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hello, Django girls!
```

Примечание: Windows не распознаёт команду 'python3'. Вместо этогодля запуска файла используй команду 'python':

{% filename %}command-line{% endfilename %}
```python
> python python_intro.py
```

Отлично! Ты только что запустила свою первую программу, код которой был сохранен в файле. Чувствуешь воодушевление?

Можно передвигаться дальше к такому незаменимому в программировании инструменту как:

## If...elif...else

Зачастую определенный код в программе должен выполняться только при соблюдении определенных условий. Поэтому в Python есть такая вещь как **условный оператор if**.

Замени код в своем файле **python_intro.py** на:

{% filename %}python_intro.py{% endfilename %}
```python
if 3 > 2:
```

Если мы сохраним его и запустим, то получим ошибку:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
File "python_intro.py", line 2
         ^
SyntaxError: unexpected EOF while parsing
```

Python предполагает, что мы должны дать ему инструкции, которые будут им выполнены при соблюдении условия `3 > 2` (т. е. при равенстве условия логическому значению `True`). Давай попробуем заставить Python напечатать на экране “It works!”. Внеси следующие изменения в **python_intro.py**:

{% filename %}python_intro.py{% endfilename %}
```python
if 3 > 2:
    print('It works!')
```

Обратила внимание, что мы сделали отступ во второй строке из 4 символов пробела? Мы поступаем так, чтобы Python понимал, какой код после условного оператора if должен быть выполнен, если условие равно True. Можно ограничиться и одним пробелом, однако практически все программисты Python используют 4, чтобы код выглядел аккуратно и читабельно. Каждая `табуляция` также считается за 4 пробела.

Сохраняем и запускаем ещё раз:

{% filename %}command-line{% endfilename %}
```python
$ python3 python_intro.py
It works!
```

Примечание: запомни, что Windows не распознаёт команду 'python3'. Всегда используй 'python' вместо 'python3' для запуска файлов.

### Что, если условие не True?

В предыдущем примере код выполнялся только когда условие равнялось True. Однако Python имеет операторы `elif` и `else`:

{% filename %}python_intro.py{% endfilename %}
```python
if 5 > 2:
    print('5 is indeed greater than 2')
else:
    print('5 is not greater than 2')
```

Если запустить этот код, он напечатает:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
5 is indeed greater than 2
```

Если 2 больше 5, то будет выполнена следующая команда. Просто, правда? Давай посмотрим, как работает оператор `elif`:

{% filename %}python_intro.py{% endfilename %}
```python
name = 'Sonja'
if name == 'Ola':
    print('Hey Ola!')
elif name == 'Sonja':
    print('Hey Sonja!')
else:
    print('Hey anonymous!')
```

и запускаем:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hey Sonja!
```

Видишь, что произошло? `elif` позволяет добавить дополнительные условия, которые запускаются, если предыдущие не срабатывают.

Можно использовать сколько угодно `elif` после первого `if`. Например:

{% filename %}python_intro.py{% endfilename %}
```python
volume = 57
if volume < 20:
    print("It's kinda quiet.")
elif 20 <= volume < 40:
    print("It's nice for background music")
elif 40 <= volume < 60:
    print("Perfect, I can hear all the details")
elif 60 <= volume < 80:
    print("Nice for parties")
elif 80 <= volume < 100:
    print("A bit loud!")
else:
    print("My ears are hurting! :(")
```

Python проходит через каждую проверку условия и выводит:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Perfect, I can hear all the details
```

## Комментарии

Комментариями — это строки, начинающиеся с символа `#`. Ты можешь написать всё, что тебе заблагорассудится, после символа `#`, и Python не обратит на это внимания. Комментарии могут помочь другим людям быстрее понять твой код.

Давай посмотрим, как они выглядят:

{% filename %}python_intro.py{% endfilename %}
```python
# Change the volume if it's too loud or too quiet
if volume < 20 or volume > 80:
    volume = 50
    print("That's better!")
```

Тебе не стоит писать комментарий для каждой строки кода, но он может быть полезен, чтобы пояснить причину определённых действий или добавить описание, когда код делает что-то особенно сложное.


### Подведём итог

В последних трёх упражнениях ты познакомилась с:

- __сравнением вещей__ — в Python ты можешь сравнивать вещи друг с другом при помощи `>`, `>=`, `==`, `<=`, `<` и операторов `and`, `or`;
- __Boolean__ — типом объекта, который может иметь только два значения: `True` или `False`;
- __сохранением файлов__ — хранение кода в файлах позволяет выполнять длинные программы;
- __if...elif...else__ — условными операторами, которые позволяют выполнять код только при определенных условиях;
- __комментариями__ — строками, которые Python не запускает и которые позволяют документировать твой код.

Пришло время для последней части этой главы!

## Твоя собственная функция!

> Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: Functions](https://www.youtube.com/watch?v=5owr-6suOl0).

Помнишь функции, такие как `len()`, которые можно использовать в Python? Тогда у нас есть хорошая новость — сейчас ты научишься писать свои собственные функции!

Функция — это последовательность инструкций, которые должен выполнить Python. Каждая функция в Python начинается с ключевого слова `def`, имеет свое имя и параметры. Давай начнем с простого примера. Замени код в **python_intro.py** на следующий:

{% filename %}python_intro.py{% endfilename %}
```python
def hi():
    print('Hi there!')
    print('How are you?')

hi()
```


Отлично, наша первая функция готова!

Ты можешь задаться вопросом, почему мы написали имя функции в конце файла. Причина в том, что Python читает и исполняет код из файла сверху вниз. Поэтому для использования нашей функции мы должны вызвать её в конце файла.

Давай запустим и посмотрим, что произойдет:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hi there!
How are you?
```

Примечание: если это не сработало, не поддавайся панике! Вывод командной строки поможет тебе понять, почему так произошло:
- Если ты получила ошибку `NameError`, то, возможно, ты что-то неправильно ввела, поэтому проверь, что ты использовала одно и то же имя при создании функции в строке `def hi():` и при её вызове в строке `hi()`.
- Если ты получила ошибку `IndentationError`, проверь, что обе строки с вызовом `print` начинаются с одинакового количества проблелов: python хочет, чтобы весь код внутри функции был аккуратно выровнен.
- Если при запуске команда не вывела вообще ничего, проверь, чтобы в начале последней строки `hi()` *не было* отступа — если он есть, эта строка тоже становится частью функции, и функция никогда не запустится.

Давай напишем нашу первую функцию с параметрами. Мы будем использовать предыдущий пример — функцию, которая пишет 'hi' и имя пользователя:

{% filename %}python_intro.py{% endfilename %}
```python
def hi(name):
```

Как ты можешь заметить, мы передали нашей функции параметр `name`:

{% filename %}python_intro.py{% endfilename %}
```python
def hi(name):
    if name == 'Ola':
        print('Hi Ola!')
    elif name == 'Sonja':
        print('Hi Sonja!')
    else:
        print('Hi anonymous!')

hi()
```

Помни: функция `print` расположена внутри блока оператора `if` с отступом в четыре пробела. Это потому, что она запускается тогда, когда выполняется условие. Давай посмотрим, как это работает:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Traceback (most recent call last):
File "python_intro.py", line 10, in <module>
  hi()
TypeError: hi() missing 1 required positional argument: 'name'
```

Упс, ошибка. К счастью, Python выдает довольно подробное сообщение об ошибке. Оно говорит нам, что функция `hi()` (которую мы определили) имеет один обязательный аргумент (`name`), и мы забыли передать его при вызове функции. Давай исправим это в конце файла:

{% filename %}python_intro.py{% endfilename %}
```python
hi("Ola")
```

И запустим ещё раз:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hi Ola!
```

А если мы поменяем имя?

{% filename %}python_intro.py{% endfilename %}
```python
hi("Sonja")
```

И повторим:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hi Sonja!
```

Теперь, как ты думаешь, что произойдет, если ты наберешь другое имя? (Не Ola или Sonja) Попробуй сама и проверь, была ли ты права. Результат должен быть таким:

{% filename %}command-line{% endfilename %}
```
Hi anonymous!
```

Шикарно, верно? Так тебе не придется повторяться каждый раз, когда ты захочешь изменить имя. И это именно та причина, для которой нам и нужны функции — ты никогда не захочешь повторять свой код!

Давай попробуем что-то похитрее — существует немало имён, и писать условие для каждого будет тяжело, правда?

{% filename %}python_intro.py{% endfilename %}
```python
def hi(name):
    print('Hi ' + name + '!')

hi("Rachel")
```

Давай выполним этот код:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hi Rachel!
```


Поздравляем! Ты только что научилась писать свои собственные функции :)

## Циклы

>  Для проходящих руководство дома: этот раздел рассмотрен в видео [Python Basics: For Loop](https://www.youtube.com/watch?v=aEA6Rc86HF0).

Ну вот и последняя часть. Быстро время пролетело, верно? :)

Программисты не любят повторяться. Программирование — это автоматизация вещей, поэтому мы не хотим приветствовать каждого человека по имени вручную, верно? Здесь пригодятся циклы.

Еще помнишь о списках? Давай создадим список девушек:

{% filename %}python_intro.py{% endfilename %}
```python
girls = ['Rachel', 'Monica', 'Phoebe', 'Ola', 'You']
```

Мы хотим поздороваться с каждой по имени. У нас есть функция `hi`, которая этим и занимается, так что давай поместим её в цикл:

{% filename %}python_intro.py{% endfilename %}
```python
for name in girls:
```

Оператор `for` работает по схожему принципу что и `if`; в коде после обоих операторов должен быть отступ в четыре пробела.

Ниже полный код, который должен быть у нас в файле:

{% filename %}python_intro.py{% endfilename %}
```python
def hi(name):
    print('Hi ' + name + '!')

girls = ['Rachel', 'Monica', 'Phoebe', 'Ola', 'You']
for name in girls:
    hi(name)
    print('Next girl')
```

И после запуска:

{% filename %}command-line{% endfilename %}
```
$ python3 python_intro.py
Hi Rachel!
Next girl
Hi Monica!
Next girl
Hi Phoebe!
Next girl
Hi Ola!
Next girl
Hi You!
Next girl
```

Как ты можешь заметить, все команды внутри цикла `for` (с отступом от левого края) будут выполняться для каждого элемента списка `girls`.

Ты также можешь использовать цикл `for` с числами с помощью функции `range`:

{% filename %}python_intro.py{% endfilename %}
```python
for i in range(1, 6):
    print(i)
```

Что выведет на экран:

{% filename %}command-line{% endfilename %}
```
1
2
3
4
5
```

Функция `range` создает список чисел, следующих от первого до второго с заданным шагом (начало, конец и шаг мы передаем функции как параметры; если шаг не указать, как в примере выше, он будет по умолчанию равен 1).

Обрати внимание что второе число (конец списка) не включается в результат работы функции (`range(1, 6)` создает список от 1 до 5, не включающий 6). Это потому, что «range» — полуоткрытый диапазон, то есть включает в себя первое значение, но не включает последнего.

## Подведём итог

Вот и всё. __Ты чертовски крута!__ Эта глава была непростой, так что ты можешь гордиться собой. Мы-то точно тобой гордимся — вон как далеко продвинулась уже!

Тебе может потребоваться перерыв — прогуляйся и дай отдых глазам перед тем, как мы перейдем к следующей главе. :)

![Пирожок][3]

 [3]: images/cupcake.png
